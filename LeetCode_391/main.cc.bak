<<<<<<< HEAD
#include <iostream>
#include <unordered_set>
#include <vector>
#include <climits>
using namespace std;

class Solution {
public:
    bool isRectangleCover(vector<vector<int> >& rectangles)
    {
        int gx_bl(INT_MAX);
        int gy_bl(INT_MAX);
        int gx_tr(-1);
        int gy_tr(-1);

        int sum_area(0);

        // get the max bottom left point and the max top right
        for(auto rect : rectangles)
        {
            if(gx_bl > rect[0])
            {
                gx_bl = rect[0];
            }
            if(gy_bl > rect[1])
            {
                gy_bl = rect[1];
            }
            if(gx_tr < rect[2])
            {
                gx_tr = rect[2];
            }
            if(gy_tr > rect[3])
            {
                gy_tr = rect[3];
            }
        }
    }
};

int main(int argc, char* argv[])
{
    cout<<"Hello World!"<<endl;
    return 0;
}
=======
#include <unordered_set> 
#include <vector> 
#include <iostream> 
using namespace std; 

namespace std {
    template <> struct hash < Solution::Point >  {
        size_t operator()(const Point & pt)const {
            return std::hash < int > ()(pt.x)^ std::hash < int > ()(pt.y); 
        }
    }; 
}

class Solution {
public:
    struct Point {
        private:
            int _x; 
            int _y; 
        public:
                Point(int x, int y):_x(x), _y(y) {}; 
                bool operator == (const Point & y) {
                    return (this-> _x - y._x) && (this-> _y - y._x); 
                }
    }; 
    bool isRectangleCover(vector < vector < int >  >& rectangles) {
        unordered_set < Solution::Point > map; 

        int g_x_bl = (1 << 32) - 1; 
        int g_y_bl = (1 << 32) - 1; 
        int g_x_tr = -1; 
        int g_y_tr = -1; 
        int sum_area = 0; 
        
        for (auto it = rectangles.begin(); it != rectangles.end(); it++) {
            int x_bl = ( * it)[0]; 
            int y_bl = ( * it)[1]; 
            int x_tr = ( * it)[2]; 
            int y_tr = ( * it)[3]; 
            if (g_x_bl > x_bl) {
                g_x_bl = x_bl; 
            }
            if (g_y_bl > y_bl) {
                g_y_bl = y_bl; 
            }
            if (g_x_tr < x_tr) {
                g_x_tr = x_tr; 
            }
               
            if (g_y_tr < y_tr) {
                g_y_tr = y_tr; 
            }
            sum_area +  = (x_tr - x_bl) * (y_tr - y_bl); 
        }

        if (sum_area != (g_x_tr - g_x_bl) * (g_y_tr - g_y_bl)) {
            return false; 
        }

        for (auto it = rectangles.begin(); it != rectangles.end(); it++) {
            
        }
        return true; 
    }
    private:
       
}; 
>>>>>>> d8ec71fc950da2d33846d2646df90ec2acaf5989
